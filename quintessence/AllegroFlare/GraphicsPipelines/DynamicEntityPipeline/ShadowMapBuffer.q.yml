properties:


  - name: entity_pool
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: true

  - name: shadow_mapping_shader
    type: AllegroFlare::Shaders::ShadowMapping*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: shadow_depth_map_renderer
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::ShadowDepthMapRenderer2*
    init_with: nullptr
    getter: true
    setter: true

  - name: result_surface_width
    type: int
    init_with: 1920
    getter: true
    setter: explicit

  - name: result_surface_height
    type: int
    init_with: 1080
    getter: true
    setter: explicit

  - name: render_surface
    type: AllegroFlare::RenderSurfaces::Bitmap
    init_with: ''
    getter_ref: true
    getter: false
    setter: false

  - name: initialized
    type: bool
    init_with: false


methods:


  - name: set_result_surface_width
    parameters:
      - name: width
        type: int
        default_argument: 1920
    guards: [ (!initialized), (width >= 320) ]
    body: |
      // TODO: Test guard
      this->result_surface_width = result_surface_width;
      return;


  - name: set_result_surface_height
    parameters:
      - name: height
        type: int
        default_argument: 1080
    guards: [ (!initialized), (height >= 240) ]
    body: |
      // TODO: Test guard
      this->result_surface_height = result_surface_height;
      return;


  - name: setup_result_surface_bitmap
    guards: [ (!initialized) ]
    body: |
      render_surface.set_surface_width(result_surface_width);
      render_surface.set_surface_height(result_surface_height);
      render_surface.set_multisamples(0);
      render_surface.set_depth(32);
      render_surface.initialize();

      initialized = true;

      return;


  - name: render
    guards:
      - initialized
      - entity_pool
      - shadow_mapping_shader
      - shadow_depth_map_renderer
    body: |
      AllegroFlare::Camera3D *primary_camera = find_primary_camera_3d();

      // Draw the shadow_depth_map_render
      if (shadow_depth_map_renderer)
      {
         shadow_depth_map_renderer->render();
      }


      using namespace AllegroFlare::GraphicsPipelines::DynamicEntityPipeline;

      ALLEGRO_BITMAP *render_surface_bmp = render_surface.obtain_surface();

      al_set_target_bitmap(render_surface_bmp);


      al_clear_depth_buffer(1);
      //al_clear_to_color(ALLEGRO_COLOR{0.1, 0.105, 0.12, 1.0});
      al_clear_to_color(ALLEGRO_COLOR{0.98 - 0.005, 0.986 - 0.005, 0.99 - 0.005, 1.0}); // NOTE This is only a non-white
                                                                                        // color to make it a little
                                                                                        // easier for debugging

      primary_camera->setup_projection_on(render_surface_bmp);





      // Activate the shader
      shadow_mapping_shader->activate();

      // Obtain our shadow_depth_map_render texture and light position
      ALLEGRO_BITMAP *shadow_depth_map_render = shadow_depth_map_renderer->get_result_surface_bitmap();
      AllegroFlare::Camera3D &light = shadow_depth_map_renderer->get_casting_light_ref();
      ALLEGRO_TRANSFORM transform;
      shadow_depth_map_renderer->setup_transform_for_light(&transform);

      // Set the uniforms on the shader
      shadow_mapping_shader->set_sampler("me__depth_pass_sampler", shadow_depth_map_render, 0);
      shadow_mapping_shader->set_mat4("me__depth_pass_transform", &transform);





      // Set the camera position in the iridescent shder
      //cubemap_shader->set_camera_position(primary_camera->get_real_position());

      for (auto &entity : entity_pool->get_entity_pool_ref())
      {
         // TODO: Rename legacy "as_agc_entity" to something more appropriate
         Entities::Base *as_agc_entity = static_cast<Entities::Base*>(entity);
         // Skip if entity is flagged as "do not render"
         // TODO: Add test for this case
         if (as_agc_entity->exists(EntityRenderFlags::DO_NOT_RENDER)) continue;
         

         ALLEGRO_TRANSFORM object_transform; // TODO: Consider alternative, add clarity if the
                                             // object performs the transform or if the objects placement is
                                             // passed along to the shader. You will need to update/align all the
                                             // shaders/renderers together


         al_identity_transform(&object_transform);
         shadow_mapping_shader->set_mat4("me__object_position_transform", &object_transform);


         // Extract the model type that is being rendered
         AllegroFlare::Model3D *model = get_model_3d(as_agc_entity);
         AllegroFlare::MultitextureModel3D *multitexture_model_3d = nullptr;

         if (model)
         {
            AllegroFlare::Placement3D *placement = get_placement_3d(as_agc_entity);
            if (!placement) continue; // TODO: Test this line

            // Collect render flags
            bool renders_with_iridescent = as_agc_entity->exists(EntityRenderFlags::RENDER_WITH_SKYBOX);

            // Setup the render for this object
            if (renders_with_iridescent)
            {
               // NOTE: For now, this has to be set before activating the shader
               //cubemap_shader->set_object_placement(placement);
               //cubemap_shader->activate();
               //ALLEGRO_TRANSFORM object_transform;
               placement->build_transform(&object_transform);
               shadow_mapping_shader->set_mat4("me__object_position_transform", &object_transform);
            }
            else
            {
               //ALLEGRO_BITMAP *texture = get_texture(as_agc_entity);
               //if (texture) model->set_texture(texture);
               //placement->start_transform();
               //ALLEGRO_TRANSFORM object_transform;
               placement->build_transform(&object_transform);
               shadow_mapping_shader->set_mat4("me__object_position_transform", &object_transform);
            }

            // Draw the model
            model->set_texture(nullptr);
            model->draw();

            // Teardown the render for this object
            if (renders_with_iridescent)
            {
               //cubemap_shader->deactivate();
            }
            else
            {
               //placement->restore_transform();
            }
         }
         else if ((multitexture_model_3d = get_multitexture_model_3d(as_agc_entity)))
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::ShadowMapBuffer::render",
               "models of type Multitexture3D are nor supported at this point in the pipeline. Please consider using "
                  "a DynamicModel3D instead."
            );
            //throw std::rut
            // Isolate our entity's type
            //Entities::StaticMultitextureModel3D *as_multitexture_model_3d_entity =
               //static_cast<Entities::StaticMultitextureModel3D*>(entity);

            // Extract out our textures
            //ALLEGRO_BITMAP *texture_a = get_texture(as_agc_entity);
            //if (texture_a) as_multitexture_model_3d_entity->set_multitexture_model_3d_texture_1(texture_a);
            //else throw std::runtime_error("no texture_a"); // TODO: Improve this error message

            //ALLEGRO_BITMAP *texture_b = get_texture_2(as_agc_entity);
            //if (texture_b) as_multitexture_model_3d_entity->set_multitexture_model_3d_texture_2(texture_b);
            //else throw std::runtime_error("no texture_b"); // TODO: Improve this error message


            // Assign the textures to the shader
            //multitexture_shader->set_texture_a(texture_a);
            //multitexture_shader->set_texture_b(texture_b);

            // Activate the shader
            //multitexture_shader->activate();

            // Render our subject
            // NOTE: For this test, will not be using "subject.draw()". Instead we will be rendering manually, and
            // setting  textures on the shader manually
            //std::vector<AllegroFlare::ALLEGRO_VERTEX_WITH_TWO_UVS_AND_NORMAL> &vertices =
               //multitexture_model_3d->vertexes;

            //al_draw_prim(
               //&vertices[0],
               //multitexture_model_3d->vertex_declaration,
               //nullptr, // TODO: In this sloppy case, this texture is used to determine the
                        // dimensionality of the textures(s) of the shader. Note that at the time of this writing, the
                        // textures and dimensions are all inter-dependent on each other in this way. This kink
                        // should eventually be worked out and cleaned up.
               //0,
               //vertices.size(),
               //ALLEGRO_PRIM_TRIANGLE_LIST
            //);

            //multitexture_shader->deactivate();
         }
         else // (!model) or (!multitexture_model)
         {
            //ALLEGRO_BITMAP *texture = get_texture(as_agc_entity);
            //AllegroFlare::Placement3D *placement = get_placement_3d(as_agc_entity);

            //if (texture)
            //{
               //placement->start_transform();
               //al_draw_bitmap(texture, 0, 0, ALLEGRO_FLIP_VERTICAL);
               //placement->restore_transform();
            //}
         }
      }

      shadow_mapping_shader->deactivate();

      return;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityRenderFlags
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Camera3D


  - name: find_primary_camera_3d
    type: AllegroFlare::Camera3D*
    body: |
      Entities::Base *entity = entity_pool->find_with_attribute("primary_camera");
      if (!entity)
      {
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::ShadowMapBuffer::primary_camera_3d",
            "no camera present"
         );
      }
      // TODO: validate the camera is of type Entities::Camera
      Entities::Camera3D *as_camera = static_cast<Entities::Camera3D*>(entity);
      return &as_camera->get_camera_3d_ref();
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: get_multitexture_model_3d
    type: AllegroFlare::MultitextureModel3D*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      using namespace AllegroFlare::GraphicsPipelines::DynamicEntityPipeline;

      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(Entities::StaticMultitextureModel3D::TYPE))
      {
         Entities::StaticMultitextureModel3D *as_casted = static_cast<Entities::StaticMultitextureModel3D*>(entity);
         return as_casted->get_multitexture_model_3d();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticMultitextureModel3D
   

  - name: get_model_3d
    type: AllegroFlare::Model3D*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return as_casted->get_model_3d();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return as_casted->get_model_3d();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

  - name: get_placement_3d
    type: AllegroFlare::Placement3D*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return &as_casted->get_placement_ref();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return &as_casted->get_placement_ref();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

  - name: get_texture
    type: ALLEGRO_BITMAP*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      using namespace AllegroFlare::GraphicsPipelines::DynamicEntityPipeline;

      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return as_casted->get_model_3d_texture();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return as_casted->get_model_3d_texture();
      }
      if (entity->is_type(Entities::StaticMultitextureModel3D::TYPE))
      {
         Entities::StaticMultitextureModel3D *as_casted = static_cast<Entities::StaticMultitextureModel3D*>(entity);
         return as_casted->get_multitexture_model_3d_texture_1();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticMultitextureModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

  - name: get_texture_2
    type: ALLEGRO_BITMAP*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      using namespace AllegroFlare::GraphicsPipelines::DynamicEntityPipeline;

      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(Entities::StaticMultitextureModel3D::TYPE))
      {
         Entities::StaticMultitextureModel3D *as_casted = static_cast<Entities::StaticMultitextureModel3D*>(entity);
         return as_casted->get_multitexture_model_3d_texture_2();
      }
      //else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      //{
         //Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         //return as_casted->get_model_3d_texture();
      //}
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticMultitextureModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

dependencies:


  - symbol: AllegroFlare::Placement3D
    headers: [ AllegroFlare/Placement3D.hpp ]
  - symbol: AllegroFlare::Model3D
    headers: [ AllegroFlare/Model3D.hpp ]
  - symbol: AllegroFlare::Camera3D
    headers: [ AllegroFlare/Camera3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/Base.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityPool.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Camera3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/Camera3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/StaticModel3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/DynamicModel3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticMultitextureModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/StaticMultitextureModel3D.hpp ]
  - symbol: AllegroFlare::MultitextureModel3D
    headers: [ AllegroFlare/MultitextureModel3D.hpp ]
  - symbol: AllegroFlare::Shaders::Cubemap
    headers: [ AllegroFlare/Shaders/Cubemap.hpp ]
  - symbol: AllegroFlare::Shaders::Multitexture
    headers: [ AllegroFlare/Shaders/Multitexture.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityRenderFlags
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityRenderFlags.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::ShadowDepthMapRenderer2
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/ShadowDepthMapRenderer2.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::RenderSurfaces::Bitmap
    headers: [ AllegroFlare/RenderSurfaces/Bitmap.hpp ]
  - symbol: AllegroFlare::Shaders::ShadowMapping
    headers: [ AllegroFlare/Shaders/ShadowMapping.hpp ]


