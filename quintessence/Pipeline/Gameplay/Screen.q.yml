parent_classes:


  - class: AllegroFlare::Screens::Base
    scope: public
    init_with: Pipeline::Gameplay::Screen::TYPE

  - class: Pipeline::EntityAttributes
    scope: public
    init_with: ''


properties:


  - name: framework
    type: AllegroFlare::Frameworks::Full*
    init_with: nullptr
    constructor_arg: true

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true

  - name: model_bin
    type: AllegroFlare::ModelBin*
    init_with: nullptr
    constructor_arg: true

  - name: game_configuration
    type: AllegroFlare::GameConfigurations::Base*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: game_progress_and_state_info
    type: Pipeline::GameProgressAndStateInfo*
    init_with: nullptr
    getter: true
    setter: true

  - name: entity_pool
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool
    init_with: ''

  - name: player_controlled_entity
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
    init_with: nullptr

  - name: player_control_velocity
    type: AllegroFlare::Vec2D
    init_with: ''

  - name: player_control_dashing
    type: bool
    init_with: false

  - name: level_camera_zones
    type: std::vector<Pipeline::Gameplay::LevelCameraZone>
    init_with: '{}'

  - name: goal_entity
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
    init_with: nullptr

  - name: exit_entity
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
    init_with: nullptr

  - name: scene_renderer
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::SceneRenderer2
    init_with: ''

  - name: show_map_overlay
    type: bool
    init_with: false

  - name: current_level_identifier
    type: std::string
    init_with: '"[unset-current_level]"'

  - name: current_level
    type: Pipeline::Gameplay::Level*
    init_with: nullptr

  - name: current_level_tile_maps
    type: std::vector<LabyrinthOfLore::WorldMap::TileMap*>
    init_with: '{}'

  - name: current_level_tile_map_tile_alignment_offset
    type: AllegroFlare::Vec2D
    init_with: '{ 0.5, -0.5 }'

  - name: currently_performing_song_identifier
    type: std::string
    init_with: '""'

  - name: currently_performing_song_duration_sec
    type: float
    init_with: 0.0f

  - name: on_finished_callback_func
    type: std::function<void(Pipeline::Gameplay::Screen*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: on_finished_callback_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false

  - name: TYPE
    type: char*
    init_with: '(char*)"Pipeline/Gameplay/Screen"'
    static: true
    constexpr: true

  - name: state
    type: uint32_t
    init_with: STATE_UNDEF
    getter: true
    setter: explicit

  - name: state_is_busy
    type: bool
    init_with: false

  - name: state_changed_at
    type: float
    init_with: 0.0f

  - name: player_is_colliding_on_goal
    type: bool
    init_with: false

  - name: player_is_colliding_on_exit
    type: bool
    init_with: false

  - name: entities_player_entity_is_colliding_with
    type: std::set<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*>
    init_with: '{}'

  - name: portal_entity_associations
    type: std::map<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*,
                   AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*>
    init_with: '{}'


enums:


  - name: State
    enumerators:
      - STATE_UNDEF
      - STATE_REVEALING
      - STATE_PLAYING_GAME
      - STATE_SUSPEND_FOR_DIALOG
      - STATE_PERFORMING_MUSIC


methods:


  - name: obtain_data_folder
    type: std::string
    guards: [ initialized, framework ]
    body: |
      return framework->get_data_folder_path();


  - name: set_framework
    guards: [ (!initialized) ]
    parameters:
      - name: framework
        type: AllegroFlare::Frameworks::Full*
        default_argument: nullptr
    body: |
      this->framework = framework;
      return;


  - name: set_event_emitter
    guards: [ (!initialized) ]
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    body: |
      this->event_emitter = event_emitter;
      return;


  - name: set_bitmap_bin
    guards: [ (!initialized) ]
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    body: |
      this->bitmap_bin = bitmap_bin;
      return;


  - name: set_font_bin
    guards: [ (!initialized) ]
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    body: |
      this->font_bin = font_bin;
      return;


  - name: set_model_bin
    guards: [ (!initialized) ]
    parameters:
      - name: model_bin
        type: AllegroFlare::ModelBin*
        default_argument: nullptr
    body: |
      this->model_bin = model_bin;
      return;
      return;


  - name: build_elevations_and_indices_for_floors
    type: std::map<int, float>
    guards: [ current_level ]
    body: |
      std::map<int, float> result;
      int i=0;
      // TODO: Confirm not duplicating levels
      //std::cout << "========" << std::endl;
      for (auto &tile_map : current_level->get_tile_maps_ref())
      {
         result[i] = tile_map.get_groundlevel_height();
         //std::cout << i << ":" << tile_map.get_groundlevel_height() << std::endl;
         i++;
      }
      // Sanity check
      if (result.size() != current_level->get_tile_maps_ref().size())
      {
         throw std::runtime_error("Pipeline::Gameplay::Screen::build_elevations_and_for_floors: error: result size "
                 "doesn't match source size");
      }
      return result;


  - name: trivial_collide
    type: bool
    parameters:
      - name: p1
        type: AllegroFlare::Vec3D
        default_argument: '{0.0f, 0.0f, 0.0f}'
      - name: p2
        type: AllegroFlare::Vec3D
        default_argument: '{0.0f, 0.0f, 0.0f}'
      - name: min_distance
        type: float
        default_argument: 10.0f
    body: |
      float squared_distance = (p1.x - p2.x) * (p1.x - p2.x)
                             + (p1.y - p2.y) * (p1.y - p2.y)
                             + (p1.z - p2.z) * (p1.z - p2.z);
      float min_distance_squared = min_distance * min_distance;
      return squared_distance < min_distance_squared;


  - name: set_primary_camera_to_gameplay_view
    parameters:
      - name: primary_camera
        type: AllegroFlare::Camera3D*
        default_argument: nullptr
    body: |
      //AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
      primary_camera->stepout = { 0.0, 0.0, 18.0 };
      primary_camera->spin = 0.5;
      primary_camera->tilt = 0.75;
      primary_camera->zoom = 3.0;
      return;


  - name: set_primary_camera_to_dialog_view
    parameters:
      - name: primary_camera
        type: AllegroFlare::Camera3D*
        default_argument: nullptr
    body: |
      //AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
      primary_camera->stepout = { 0.0, 0.0, 10.0 };
      primary_camera->spin = 0.5 - 0.2;
      primary_camera->tilt = 0.75 - 0.4;
      primary_camera->zoom = 2.8;
      return;


  - name: set_primary_camera_to_music_performance_view
    parameters:
      - name: primary_camera
        type: AllegroFlare::Camera3D*
        default_argument: nullptr
    body: |
      //AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
      primary_camera->stepout = { 0.0, 0.25, 6.0 };
      primary_camera->spin = 0.2;
      primary_camera->tilt = 0.2;
      primary_camera->zoom = 3.1;
      return;


  - name: set_primary_camera_to_custom_view_1
    parameters:
      - name: primary_camera
        type: AllegroFlare::Camera3D*
        default_argument: nullptr
    body: |
      //AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
      primary_camera->stepout = { 0.0, 2.4, 20.0 };
      primary_camera->spin = 1.2;
      primary_camera->tilt = 0.3;
      primary_camera->zoom = 3.6;
      return;


  - name: build_dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    body: |
      return Pipeline::DialogNodeBankFactory::build_production_game_node_bank();
    body_dependency_symbols:
      - Pipeline::DialogNodeBankFactory


  - name: lowest_y_vertex
    type: AllegroFlare::Vec3D
    parameters:
      - name: vertices
        type: std::vector<AllegroFlare::ALLEGRO_VERTEX_WITH_NORMAL>
        default_argument: '{}'
    guards: [ (!vertices.empty()) ]
    body: |
      AllegroFlare::ALLEGRO_VERTEX_WITH_NORMAL result = vertices[0];
      for (auto &vertex : vertices)
      {
         if (vertex.y < result.y) result = vertex;
      }
      return AllegroFlare::Vec3D{result.x, result.y, result.z};


  - name: find_named_object_identifiers_for_portals
    type: std::set<std::string>
    parameters:
      - name: world_model
        type: AllegroFlare::Model3D*
        default_argument: nullptr
    guards: [ world_model ]
    body: |
      std::set<std::string> portal_names;
      std::vector<AllegroFlare::Model3D::named_object> &named_objects = world_model->named_objects;
      for (auto &named_object : named_objects)
      {
         std::string identifier = named_object.identifier;
         if (identifier.compare(0, 7, "portal-") == 0)
         {
            portal_names.insert(identifier);
         }
      }

      // Verify there are two of each
      for (auto &portal_name : portal_names)
      {
         int num_with_name = world_model->count_num_named_objects_with_name(portal_name);
         if (num_with_name != 2)
         {
            AllegroFlare::Logger::throw_error(
               "Pipeline::Gameplay::Screen::find_portal_named_object_identfiers",
               "Expecting there to be only 2 objects with a portal name, but there were \""
                  + std::to_string(num_with_name) + "\" with the name \"" + portal_name + "\""
            );
         }
      }

      return portal_names;
    body_dependency_symbols:
       - AllegroFlare::Logger


  - name: build_level
    type: Pipeline::Gameplay::Level
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    body: |
      ///*
      std::string data_folder = obtain_data_folder();
      std::string levels_csv_file = data_folder + "/levels/universe.csv";

      bool csv_file_exists = std::filesystem::exists(levels_csv_file);
      if (!csv_file_exists)
      {
         AllegroFlare::Logger::throw_error(
            "Pipeline::Gameplay::Screen::build_level",
            "The CSV file \"" + levels_csv_file + "\" does not exist."
         );
      }
      
      Pipeline::CSVToLevelLoader csv_level_loader;
      csv_level_loader.set_csv_full_path(levels_csv_file);
      csv_level_loader.load();

      bool level_exists = csv_level_loader.level_exists(level_identifier);
      if (!level_exists)
      {
         AllegroFlare::Logger::throw_error(
            "Pipeline::Gameplay::Screen::build_level",
            "Level with the identifier \"" + level_identifier + "\" does not exist."
         );
      }
      //*/

      return csv_level_loader.find_level(level_identifier);
    body_dependency_symbols:
      - Pipeline::CSVToLevelLoader


  - name: get_current_level_tile_map
    type: LabyrinthOfLore::WorldMap::TileMap*
    parameters:
      - name: floor_index
        type: int
        default_argument: 0
    guards: [ (!current_level_tile_maps.empty()), (floor_index >= 0), (floor_index < current_level_tile_maps.size()) ]
    body: |
      return current_level_tile_maps[floor_index]; // TODO: Grab the level nearest the player (or y-position)
     


  - name: load_tile_map
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    body: |
      for (auto &current_level_tile_map : current_level_tile_maps)
      {
         if (current_level_tile_map) delete current_level_tile_map;
      }

      current_level_tile_maps.clear();

      //int num_levels = 1;
      //for (int i=0; i<num_levels; i++)
      //{
         current_level_tile_maps = load_tile_map_from_bitmap(level_identifier); // TODO: Load each level
         //current_level_tile_maps.push_back(load_tile_map_from_bitmap(level_identifier)); // TODO: Load each level
      //}

      return;


  - name: load_tile_map_from_bitmap
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    type: std::vector<LabyrinthOfLore::WorldMap::TileMap*>
    body: |
      // TODO: Don't pass along floor, instead do better thing

      std::string tile_map_bitmap_folder_location = bitmap_bin->get_path();
      std::vector<LabyrinthOfLore::WorldMap::TileMap*> result; // = new LabyrinthOfLore::WorldMap::TileMap();

      // Create some level data

      Pipeline::Gameplay::Level level = build_level(level_identifier);


      for (auto &tile_map : level.get_tile_maps())
      {
         LabyrinthOfLore::WorldMap::TileMap *local_result = new LabyrinthOfLore::WorldMap::TileMap();
         std::string tile_elevation_bitmap = tile_map.get_tile_elevation_bitmap_filename();
         std::string tile_type_bitmap = tile_map.get_tile_type_bitmap_filename();

         //bool has_bitmap_files_for_loading = !(level.get_tile_map_tile_elevation_bitmap_filename().empty()
                                           //&& level.get_tile_map_tile_type_bitmap_filename().empty());
         bool has_bitmap_files_for_loading = !(tile_elevation_bitmap.empty() && tile_type_bitmap.empty());

         if (has_bitmap_files_for_loading)
         {
            // Load the level (with bitmap files)

            std::string elevation_bitmap_filename = tile_map_bitmap_folder_location
                                                  + tile_elevation_bitmap; //level.get_tile_map_tile_elevation_bitmap_filename();
            std::string tile_type_bitmap_filename = tile_map_bitmap_folder_location
                                                  + tile_type_bitmap; //level.get_tile_map_tile_type_bitmap_filename();
            //float ceiling_height = level.get_tile_map_ceiling_height();
            //float ground_height = level.get_tile_map_groundlevel_height();
            //float floor_height = level.get_tile_map_floor_height();
            float ceiling_height = tile_map.get_ceiling_height();
            float ground_height = tile_map.get_groundlevel_height();
            float floor_height = tile_map.get_floor_height();


            std::cout << "-- elevation_bitmap_filename: " << elevation_bitmap_filename << std::endl;
            std::cout << "-- tile_type_bitmap_filename: " << tile_type_bitmap_filename << std::endl;

            if (!std::filesystem::exists(elevation_bitmap_filename))
            {
               AllegroFlare::Logger::throw_error(
                  "Pipeline::Gameplay::Screen::load_tile_map_from_bitmap",
                  "The tile_elevation bitmap \"" + elevation_bitmap_filename + "\" does not exist."
               );
            }
            if (!std::filesystem::exists(tile_type_bitmap_filename))
            {
               AllegroFlare::Logger::throw_error(
                  "Pipeline::Gameplay::Screen::load_tile_map_from_bitmap",
                  "The tile_type bitmap \"" + tile_type_bitmap_filename + "\" does not exist."
               );
            }

            LabyrinthOfLore::WorldMap::MultiBitmapFilenameToWorldBuilder world_builder(
               elevation_bitmap_filename,
               tile_type_bitmap_filename,
               ceiling_height,
               ground_height,
               floor_height
            );

            *local_result = world_builder.build();

            result.push_back(local_result);
         }
         else
         {
            // No bitmap data is available for this level
            AllegroFlare::Logger::warn_from(
               "Pipeline::Gameplay::Screen::load_tile_map_from_bitamp",
               "Level bitmaps are not used for the level with identifier \"" + level_identifier + "\""
                  ". Proceeding with an empty tile_map for collisions."
            );
         }
      }

      return result;
    body_dependency_symbols:
      - LabyrinthOfLore::WorldMap::MultiBitmapFilenameToWorldBuilder


  - name: load_tester_tile_map
    type: LabyrinthOfLore::WorldMap::TileMap*
    body: |
      //if (current_level_tile_map) delete current_level_tile_map;

      LabyrinthOfLore::WorldMap::TileMap *result_tile_map = new LabyrinthOfLore::WorldMap::TileMap();

      result_tile_map->resize(
         16,
         16,
         LabyrinthOfLore::WorldMap::Tile(
            LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE,
            0.0f
         )
      );

      // A pillar too high
      result_tile_map->set_tile(
         1, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 2.0f));

      // A sequence of steps
      result_tile_map->set_tile(
         3, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 0.2f));
      result_tile_map->set_tile(
         4, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 0.4f));
      result_tile_map->set_tile(
         5, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 0.6f));
      result_tile_map->set_tile(
         6, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 0.8f));
      result_tile_map->set_tile(
         7, 1, LabyrinthOfLore::WorldMap::Tile(LabyrinthOfLore::WorldMap::NORMAL_GROUND_TILE, 1.0f));

      //current_level_tile_map = result_tile_map;

      return result_tile_map;
 


  - name: load_level_by_identifier
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    guards: [ game_configuration, framework, model_bin, bitmap_bin ]
    body: |
      //
      // Set our local cached state variables to default
      //

      player_controlled_entity = nullptr;
      player_is_colliding_on_goal = false; // TODO: Replace this with a list of colliding objects
      player_is_colliding_on_exit = false; // TODO: Replace this with a list of colliding objects
      player_control_velocity = { 0.0f, 0.0f };
      player_control_dashing = false;
      goal_entity = nullptr;
      exit_entity = nullptr;
      entities_player_entity_is_colliding_with.clear();
      portal_entity_associations.clear();
      if (current_level) delete current_level;
      current_level = nullptr;
      for (auto &current_level_tile_map : current_level_tile_maps)
      {
         if (current_level_tile_map) delete current_level_tile_map;
      }
      current_level_tile_maps.clear();
      //if (current_level_tile_map) delete current_level_tile_map;
      //current_level_tile_map = nullptr;
      show_map_overlay = false;
      level_camera_zones.clear();



      //
      // Find the Level record matching this identifier
      //

      //level = new Pipeline::Gameplay::Level();
      Pipeline::Gameplay::Level level = build_level(level_identifier);



      //*current_level = level;


      //level.set_tile_map_tile_elevation_bitmap_filename("the_cave.png");
      //level.set_tile_map_tile_type_bitmap_filename("the_cave-type.png");
      //level.set_tile_map_ceiling_height(10.0f);
      //level.set_tile_map_groundlevel_height(0.0f);
      //level.set_tile_map_floor_height(-2.0f);
      //level.set_tile_map_origin_offset({22, 25});




      //std::string world_model_name = level_identifier; //"world-1-01";
      std::string world_model_obj_name = level.get_world_model_obj_filename(); //world_model_name + ".obj";
      std::string world_model_texture_name = level.get_world_model_texture_filename(); //world_model_name + ".png";


      std::string background_music_identifier = level.get_background_music_identifier();


      //
      // Clear our resources so they can be processed from freshly loaded models
      //

      model_bin->clear();
      // TODO: Clear model_bin and the entity_pool
      for (auto &entity : entity_pool.get_entity_pool_ref())
      {
         delete entity;
         //entity_pool.clear();
      }
      entity_pool.get_entity_pool_ref().clear();



      //
      // level_identifier
      current_level_identifier = level_identifier;

      // Begin OBJ World loader
      Pipeline::OBJWorldLoader obj_world_loader;
      obj_world_loader.set_bitmap_bin(bitmap_bin);
      obj_world_loader.set_model_bin(model_bin);
      obj_world_loader.set_world_model_obj_name(level.get_world_model_obj_filename());
      obj_world_loader.set_world_model_texture_name(level.get_world_model_texture_filename());
      entity_pool = obj_world_loader.load();

      goal_entity = obj_world_loader.get_goal_entity();
      exit_entity = obj_world_loader.get_exit_entity();
      //player_character = obj_world_loader.get_player_character();
      portal_entity_associations = obj_world_loader.get_portal_entity_associations();
      player_controlled_entity = obj_world_loader.get_player_character();
      level_camera_zones = obj_world_loader.get_level_camera_zones();



      //
      // Build the tile map (for physics)
      //

      load_tile_map(level_identifier);

      //
      // Set the current level
      //
      current_level = new Pipeline::Gameplay::Level();
      *current_level = level;

      current_level_identifier = level_identifier;




      //
      // Load the dialog bank
      //

      AllegroFlare::DialogTree::NodeBank node_bank = build_dialog_node_bank();

      // Validate important dialog nodes exist
      if (!node_bank.node_exists_by_name("package_delivery_response"))
      {
         throw std::runtime_error("Expecting \"package_delivery_response\" dialog node to exist but it does not.");
      }

      framework->set_dialog_system_dialog_node_bank(node_bank);


      //
      // Load the song to play for this level
      //
      //current_level_song_to_perform_identifier = "robot-holly_jolly";


      //
      // Assign our "special" items
      //

      //player_controlled_entity = obj_world_loader.get_player_character();
      //goal_entity = item;
      player_is_colliding_on_goal = false; // This needs to be changed to an "enter" collision e.g. "exit" collision
      player_is_colliding_on_exit = false; // This needs to be changed to an "enter" collision e.g. "exit" collision


      //
      // Set our initial positions
      //

      set_primary_camera_to_gameplay_view(scene_renderer.find_primary_camera_3d());
                                             // This will be our default initialization position, and could be modified
                                             // in the next step by starting the game


      //
      // Start the game
      //

      set_state(STATE_PLAYING_GAME);



       //
       // Play the music!

       event_emitter->emit_play_music_track_event(background_music_identifier);



      return;
    body_dependency_symbols:
     - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
     - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityRenderFlags
     - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityFactory
     - Pipeline::GameConfigurations::Main
     - AllegroFlare::ALLEGRO_VERTEX_WITH_NORMAL
     - Pipeline::Gameplay::Level
     - AllegroFlare::DialogTree::NodeBank
     - LabyrinthOfLore::WorldMap::TileTypeEnum
     - Pipeline::OBJWorldLoader


  - name: initialize
    guards:
      - (!initialized)
      - framework
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
      - al_is_font_addon_initialized()
      - event_emitter
      - bitmap_bin
      - font_bin
      - model_bin
    body: |
      // Setup scene renderer
      scene_renderer.set_entity_pool(&entity_pool);
      scene_renderer.set_data_path_for_shaders(framework->get_data_folder_path() + "shaders/");
      //scene_renderer.setup_result_surface_bitmap(1920 / 3, 1080 / 3);
      scene_renderer.setup_result_surface_bitmap(1920, 1080); // For some reason, 
      scene_renderer.setup_shadow_map_buffer();
      scene_renderer.setup_cubemapping(bitmap_bin->get_path() + "black_prism_1-01.png");
      scene_renderer.setup_multitexture_shader();

      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      //TODO: emit_event_to_update_input_hints_bar();
      //TODO: emit_show_and_size_input_hints_bar_event();
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      //TODO: emit_hide_and_restore_size_input_hints_bar_event();
      //event_emitter->emit_hide_input_hints_bar_event();
      return;


  - name: get_player_controlled_entity_as
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
    body: |
      if (!player_controlled_entity->is_type(
               AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE
            )
         )
      {
         throw std::runtime_error("unexpected player controlled entity type");
      }

      AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *as =
         static_cast<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *>(
            player_controlled_entity
         );
      return as;


  - name: get_goal_entity_as
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
    body: |
      if (!goal_entity->is_type(
               AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE
            )
         )
      {
         throw std::runtime_error("unexpected player controlled entity type");
      }

      AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *as =
         static_cast<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *>(
            goal_entity
         );
      return as;


  - name: get_exit_entity_as
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
    body: |
      if (!exit_entity->is_type(
               AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE
            )
         )
      {
         throw std::runtime_error("unexpected player controlled entity type");
      }

      AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *as =
         static_cast<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *>(
            exit_entity
         );
      return as;


  - name: get_entity_as_dynamic_model_3d
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
    parameters:
      - name: colliding_entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    body: |
      if (!exit_entity->is_type(
               AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE
            )
         )
      {
         throw std::runtime_error("unexpected entity type not being DynamicModel3D");
      }

      AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *as =
         static_cast<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D *>(
            colliding_entity
         );
      return as;


  - name: on_player_entity_raw_collide
    parameters:
      - name: colliding_entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
        default_argument: nullptr
    body: |
      if (!is_state(STATE_PLAYING_GAME)) return;

      if (colliding_entity == goal_entity)
      {
         set_state(STATE_SUSPEND_FOR_DIALOG);
         event_emitter->emit_activate_dialog_node_by_name_event("package_delivery_response");
      }
      else if (colliding_entity == exit_entity)
      {
         call_on_finished_callback_func();
      }
      return;


  - name: on_player_entity_enter_collide
    parameters:
      - name: colliding_entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
        default_argument: nullptr
    guards: [ player_controlled_entity ]
    body: |
      if (!is_state(STATE_PLAYING_GAME)) return;

      if (colliding_entity->exists(ATTRIBUTE_IS_PORTAL))
      {
         // TODO: Find teleport to next portal
         // Find this portal in list of portals
         AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D* this_portal =
            colliding_entity;
         AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D* target_portal = nullptr;
         
         // Get the correlated portal
         // TODO: Confirm exists
         if (portal_entity_associations.find(this_portal) == portal_entity_associations.end())
         {
            // This portal doesn't have an entry in the "portal_entity_associations"
            AllegroFlare::Logger::throw_error(
               "Pipeline::Gameplay::Screen::on_player_entity_enter_collide",
               "Expecting there to be an entry for portal (to find the correlated destination portal) but there was "
                  "none in the list."
            );
         }
         target_portal = portal_entity_associations[this_portal];
         if (!target_portal)
         {
            // This portal doesn't have an entry in the "portal_entity_associations"
            AllegroFlare::Logger::throw_error(
               "Pipeline::Gameplay::Screen::on_player_entity_enter_collide",
               "The portal was found in the list of \"portal_entity_associations\" but its target portal was a nullptr."
            );
         }

         // Extract the correlated portal's position
         AllegroFlare::Vec3D target_portal_position = target_portal->get_placement_ref().position;

         // Place the player character at the destiation portal
         get_player_controlled_entity_as()->get_placement_ref().position = target_portal_position;

         // Add target_portal to "colliding_with"
            // consider that the calling loop could process a "continuing to collide with" on this entered portal or not
         // TODO: Confirm is not already in the list
         entities_player_entity_is_colliding_with.insert(target_portal);
         
         // Remove the this_portal from "colliding_with"
         // TODO: Confirm is already in the list
         // TODO: Confirm is removed from list
         entities_player_entity_is_colliding_with.erase(this_portal);
      }
      else if (colliding_entity->exists(ATTRIBUTE_IS_NPC))
      {
         std::string npc_identifier = colliding_entity->get(ATTRIBUTE_NPC_IDENTIFIER);
         if (npc_identifier == NPC_FORREST_IN_THE_FOREST)
         {
            std::string quest_name = "mushroom_quest";
            bool mushroom_quest_is_finished = game_progress_and_state_info->is_quest_completed(quest_name);
            if (!mushroom_quest_is_finished)
            {
               int num_mushrooms_in_inventory =
                  game_progress_and_state_info->count_num_items_in_inventory_with_identifier("mushroom");
               int num_needed_mushrooms = 10;
               if (num_mushrooms_in_inventory >= num_needed_mushrooms)
               {
                  // On completed
                  std::string dialog_to_activate = Pipeline::DialogNodeBankFactory::DIALOG_FOREST_NPC_COMPLETES_QUEST;
                  game_progress_and_state_info->mark_quest_as_completed(quest_name);
                  emit_event_to_save_progress();
                  set_state(STATE_SUSPEND_FOR_DIALOG);
                  event_emitter->emit_activate_dialog_node_by_name_event(dialog_to_activate);
               }
               else
               {
                  // Quest not completed, give prompt
                  std::string dialog_to_activate = Pipeline::DialogNodeBankFactory::DIALOG_FOREST_NPC_LIKES_MUSHROOMS;
                  set_state(STATE_SUSPEND_FOR_DIALOG);
                  event_emitter->emit_activate_dialog_node_by_name_event(dialog_to_activate);
               }
            }
            else
            {
               // Quest is already complete
               std::string dialog_to_activate = Pipeline::DialogNodeBankFactory::DIALOG_FOREST_NPC_QUEST_ALREADY_COMPLETE;
               set_state(STATE_SUSPEND_FOR_DIALOG);
               event_emitter->emit_activate_dialog_node_by_name_event(dialog_to_activate);
            }
         }
         else
         {
            // Unhandled case for this identifier
            throw std::runtime_error("Eeks couldn't find npc handler!");
         }
      }
      else if (colliding_entity->exists(ATTRIBUTE_ITEM_TYPE, "mushroom"))
      {
         // Collect this mushroom
         // TODO: Add the attribute "COLLECTED"
         // TODO: Add the attribute "COLLECTED_AT"
         // TODO: Remove the attribute "ATTRIBUTE_COLLIDABLE_BY_PLAYER"

         // Play sound effect
         if (colliding_entity->exists(ATTRIBUTE_ITEM_PICKUP_SOUND))
         {
            std::string pickup_sound_effect = colliding_entity->get(ATTRIBUTE_ITEM_PICKUP_SOUND);
            event_emitter->emit_play_sound_effect_event(pickup_sound_effect);
         }

         // TODO: Consider preventing player from collecting more than the max allowable for this item

         // Add item to inventory
         if (!game_progress_and_state_info) throw std::runtime_error("Gameplay::Screen::on_player_entity_raw_collide AGH!");
         game_progress_and_state_info->add_item_to_inventory("mushroom");

         // Delete the entity and remove it from the scene (for now. Later, do a collect animation)
         delete colliding_entity; // TODO: Don't delete here, delete in a follow-up pass after collision and everything
         entity_pool.remove(colliding_entity);
         // Remove the entity from the list of entities_player_entity_is_colliding_with
         entities_player_entity_is_colliding_with.erase(colliding_entity);
      }
      else if (colliding_entity->exists(ATTRIBUTE_ITEM_TYPE, "red_bird"))
      {
         // Bird chirps
         // TODO: Add the attribute "COLLECTED"
         // TODO: Add the attribute "COLLECTED_AT"
         // TODO: Remove the attribute "ATTRIBUTE_COLLIDABLE_BY_PLAYER"

         // Play sound effect
         //if (colliding_entity->exists(ATTRIBUTE_ITEM_PICKUP_SOUND))
         //{
         std::string chirp_sound_effect = "red_bird_chirp";
         event_emitter->emit_play_sound_effect_event(chirp_sound_effect);
         //}

         // TODO: Consider preventing player from collecting more than the max allowable for this item

         // Add item to inventory
         //if (!game_progress_and_state_info) throw std::runtime_error("Gameplay::Screen::on_player_entity_raw_collide AGH!");
         //game_progress_and_state_info->add_item_to_inventory("mushroom");

         // Delete the entity and remove it from the scene (for now. Later, do a collect animation)
         //delete colliding_entity; // TODO: Don't delete here, delete in a follow-up pass after collision and everything
         //entity_pool.remove(colliding_entity);
         // Remove the entity from the list of entities_player_entity_is_colliding_with
         //entities_player_entity_is_colliding_with.erase(colliding_entity);
      }
      return;
    body_dependency_symbols:
      - Pipeline::DialogNodeBankFactory


  - name: on_player_entity_exit_collide
    parameters:
      - name: colliding_entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
        default_argument: nullptr
    body: |
      if (!is_state(STATE_PLAYING_GAME)) return;

      // No exit collisions at this point
      return;


  - name: find_first_camera_zone_at
    type: Pipeline::Gameplay::LevelCameraZone*
    parameters:
      - name: player_controlled_entity_as
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D*
        default_argument: nullptr
    guards: [ player_controlled_entity_as ]
    body: |
      Pipeline::Gameplay::LevelCameraZone *result = nullptr;
      AllegroFlare::Vec3D player_character_position = player_controlled_entity_as->get_placement_ref().position;

      // TODO: Find camera zone
      // HERE
      std::cout << "num camera zones: " << level_camera_zones.size() << std::endl;
      int i=0;
      for (auto &level_camera_zone : level_camera_zones)
      {
         //AllegroFlare::Physics::AABB3D box = level_camera_zone.get_bounding_box_ref();
            std::cout << "-- zone " << i << ":" << std::endl;
            auto camera_zone_bounding_box = level_camera_zone.get_bounding_box_ref();
            //camera_zone_bounding_box.set_min(build_bounding_box_min_coordinate(object_vertices));
            //camera_zone_bounding_box.set_max(build_bounding_box_max_coordinate(object_vertices));

            std::cout << "  min_x: " << camera_zone_bounding_box.get_min().x << std::endl;
            std::cout << "  max_x: " << camera_zone_bounding_box.get_max().x << std::endl;
            std::cout << "  min_y: " << camera_zone_bounding_box.get_min().y << std::endl;
            std::cout << "  max_y: " << camera_zone_bounding_box.get_max().y << std::endl;
            std::cout << "  min_z: " << camera_zone_bounding_box.get_min().z << std::endl;
            std::cout << "  max_z: " << camera_zone_bounding_box.get_max().z << std::endl;
            std::cout << "-- player:" << std::endl;
            std::cout << "  x: " << player_character_position.x << std::endl;
            std::cout << "  y: " << player_character_position.y << std::endl;
            std::cout << "  z: " << player_character_position.z << std::endl;

         if (level_camera_zone.get_bounding_box_ref().collides_with_point(player_character_position))
         {
            std::cout << "FOUND camera zone " << std::endl;
            return &level_camera_zone;
         }
      }

      return result;


  - name: update
    guards: [ current_level ]
    body: |
      update_state(); // Consider if this would need to be moved to a different place, or if it conflicts
                      // with the logic below

      // Spin our shadow casted light
      float light_spin = -1.0f;
      float light_time_of_day = 0.15f;
      AllegroFlare::Camera3D *light = scene_renderer.get_shadow_map_buffer_ref().get_light();
      //light->spin = light_spin;
      //light->tilt = 3.141592653 * light_time_of_day; // light_time_of_day = 0.05; // sunrise
                                                     //                     0.5; // high noon
                                                     //                     0.95; // sunset

      //light->spin = -0.5f;
      //light->tilt += 0.001;
      //light->spin = current_level->get_primary_light_spin();
      light->spin = current_level->get_primary_light_spin();
      light->tilt = 3.141592653 * current_level->get_primary_light_tilt_time_of_day();
      //light->spin -= 0.001;
      


      // Pan the camera
      AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
      //primary_camera->stepout.z += 0.01;
      //primary_camera->spin += 0.0005;
      //primary_camera->tilt += 0.0008;




      // HERE:
      // Check collisions on player in a camera zone
      if (player_controlled_entity)
      {
         auto player_entity_as = get_player_controlled_entity_as();
         Pipeline::Gameplay::LevelCameraZone *level_camera_zone = find_first_camera_zone_at(player_entity_as);
         if (!level_camera_zone)
         {
            set_primary_camera_to_gameplay_view(scene_renderer.find_primary_camera_3d());
            // Use the default settings
         }
         else
         {
            set_primary_camera_to_custom_view_1(scene_renderer.find_primary_camera_3d());
         }
      }




      //player_control_velocity.x = -0.001;
      bool lock_light_on_player_controlled_entity = true;
      bool lock_camera_on_player_controlled_entity = true;

      if (player_controlled_entity)
      {


         // Update the player's current velocity for this frame
         float speed_modifier = 0.046f;

         bool using_dash_controls = false;
         if (using_dash_controls)
         {
            bool player_controlled_entity_is_dashing = player_control_dashing; // TODO: Extract this from somewhere
            if (player_controlled_entity_is_dashing) speed_modifier = 0.09f;
         }

         AllegroFlare::Vec2D controlled_entity_velocity = player_control_velocity * speed_modifier;
         // Translate the player control angles to be relative to the camera
         float angle = primary_camera->spin;
         float x_prime = controlled_entity_velocity.x * std::cos(angle) - controlled_entity_velocity.y * std::sin(angle);
         float y_prime = controlled_entity_velocity.x * std::sin(angle) + controlled_entity_velocity.y * std::cos(angle);

         // Move the player
         auto player_entity_as = get_player_controlled_entity_as();
         //player_entity_as->get_placement_ref().position.x += x_prime;
         //player_entity_as->get_placement_ref().position.z += y_prime;

         //Pipeline::Physics::GravityStepper gravity_stepper;
         //gravity_stepper.set_entities({ player_entity_as });
         //gravity_stepper.process_step();



         // HERE
         float player_elevation = player_entity_as->get_placement_ref().position.y;
         std::map<int, float> floor_elevations = build_elevations_and_indices_for_floors();
         Pipeline::CurrentFloorInferencer floor_inferencer(floor_elevations);
         //floor_inferencer.set_elevationMap(floor_elevations);
         int closest_floor_index = floor_inferencer.find_closest_floor(player_elevation);

         //int inferred_floor_number =            { floor_height+4.0, floor_height, floor_height-4.0 };
         //float local_y



         // Update the player's position by applying its velocity in the stepper
         // Reposition player_character on map; Use a very fancy swapping of y-with-z variables, the stepper
         ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         LabyrinthOfLore::WorldMap::TileMap *current_level_tile_map = get_current_level_tile_map(closest_floor_index); // TODO: Pass argument
         ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         AllegroFlare::Vec2D current_level_tile_map_origin_offset = current_level->get_tile_maps()[closest_floor_index].get_origin_offset();
         //AllegroFlare::Vec2D current_level_tile_map_origin_offset = current_level->get_tile_map_origin_offset();

         AllegroFlare::Vec3D vswapper;
         AllegroFlare::Vec3D pswapper;
         player_entity_as->get_velocity_ref().position.x = x_prime;
         player_entity_as->get_velocity_ref().position.z = y_prime;


         // Apply gravity
         AllegroFlare::vec3d gravity(0.0f, -0.005f, 0.0f);
         player_entity_as->get_velocity_ref().position += gravity;



         player_entity_as->get_placement_ref().position.x += current_level_tile_map_origin_offset.x;
         player_entity_as->get_placement_ref().position.z += current_level_tile_map_origin_offset.y;
         player_entity_as->get_placement_ref().position.x += current_level_tile_map_tile_alignment_offset.x;
         player_entity_as->get_placement_ref().position.z += current_level_tile_map_tile_alignment_offset.y;
         vswapper = player_entity_as->get_velocity_ref().position;
         player_entity_as->get_velocity_ref().position.z = vswapper.y;
         player_entity_as->get_velocity_ref().position.y = vswapper.z;
         pswapper = player_entity_as->get_placement_ref().position;
         player_entity_as->get_placement_ref().position.z = pswapper.y;
         player_entity_as->get_placement_ref().position.y = pswapper.z;

         LabyrinthOfLore::Physics::EntityTileMapCollisionStepper collision_stepper;
         collision_stepper.set_tile_map(current_level_tile_map);
         collision_stepper.set_entities({ player_entity_as });
         collision_stepper.process_step();

         vswapper = player_entity_as->get_velocity_ref().position;
         player_entity_as->get_velocity_ref().position.z = vswapper.y;
         player_entity_as->get_velocity_ref().position.y = vswapper.z;
         pswapper = player_entity_as->get_placement_ref().position;
         player_entity_as->get_placement_ref().position.z = pswapper.y;
         player_entity_as->get_placement_ref().position.y = pswapper.z;
         player_entity_as->get_placement_ref().position.x -= current_level_tile_map_origin_offset.x;
         player_entity_as->get_placement_ref().position.z -= current_level_tile_map_origin_offset.y;
         player_entity_as->get_placement_ref().position.x -= current_level_tile_map_tile_alignment_offset.x;
         player_entity_as->get_placement_ref().position.z -= current_level_tile_map_tile_alignment_offset.y;




         // Update the player model rotation to face the moving direction
         if (std::fabs(x_prime) + std::fabs(y_prime) > 0.001) // Only update the rotation if the player is moving
         {
            AllegroFlare::Vec2D prime(x_prime, y_prime);
            float angle_in_radians = prime.get_angle();
            float angle_in_degrees = angle_in_radians * (180.0 / ALLEGRO_PI);
            float angle_in_units = angle_in_degrees / 360.0f;

            bool smooth = true;
            float final_angle = 0.0f;

            if (!smooth)
            {
               final_angle = -angle_in_units;
            }
            else
            {
               // Smoothly rotate our player character to the direction of travel
               float target_angle_in_units = -angle_in_units;
               float current_angle_in_units = player_entity_as->get_placement_ref().rotation.y;

               float rotation_rate = 0.1;
               float target = std::fmod(target_angle_in_units, 1.0f);
               float current = std::fmod(current_angle_in_units, 1.0f);
               float angular_distance = (target - current);

               // Use "angular wraparound" to ensure the player doesn't do an unnecessary full 360
               // If the distance is more than 0.5, subtract 1 to go the shorter way
               // If the distance is less than -0.5, add 1 to go the shorter way
               if (angular_distance > 0.5f) angular_distance -= 1.0f;
               else if (angular_distance < -0.5f) angular_distance += 1.0f;

               // Set the final angle
               final_angle = angular_distance * rotation_rate + current;
            }

            player_entity_as->get_placement_ref().rotation.y = final_angle;
         }


         if (lock_camera_on_player_controlled_entity)
         {
            primary_camera->position.x = player_entity_as->get_placement_ref().position.x;
            primary_camera->position.y = player_entity_as->get_placement_ref().position.y;
            primary_camera->position.z = player_entity_as->get_placement_ref().position.z;
         }

         if (lock_light_on_player_controlled_entity)
         {
            light->position.x = player_entity_as->get_placement_ref().position.x;
            light->position.y = player_entity_as->get_placement_ref().position.y;
            light->position.z = player_entity_as->get_placement_ref().position.z;
         }

         // Check collide with goal
         if (!goal_entity)
         {
            throw std::runtime_error("Pipeline::Gameplay::Screen::update: no goal_entity");
         }
         else
         {
            auto goal_entity_as = get_goal_entity_as();
            bool collides = trivial_collide(
               player_entity_as->get_placement_ref().position,
               goal_entity_as->get_placement_ref().position,
               1.0
            );
            if (collides)
            {
               if (!player_is_colliding_on_goal) on_player_entity_raw_collide(goal_entity_as);
               player_is_colliding_on_goal = true;
            }
            else
            {
               player_is_colliding_on_goal = false;
            }
         }

         // Check collide with exit
         if (!exit_entity)
         {
            throw std::runtime_error("Pipeline::Gameplay::Screen::update: no exit_entity");
         }
         else
         {
            auto exit_entity_as = get_exit_entity_as();
            bool collides = trivial_collide(
               player_entity_as->get_placement_ref().position,
               exit_entity_as->get_placement_ref().position,
               1.0
            );
            if (collides)
            {
               if (!player_is_colliding_on_exit) on_player_entity_raw_collide(exit_entity_as);
               player_is_colliding_on_exit = true;
            }
            else
            {
               player_is_colliding_on_exit = false;
            }
         }

         // Check collidable entities
         std::vector<AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*> collidables =
            entity_pool.find_all_with_attribute(ATTRIBUTE_COLLIDABLE_BY_PLAYER);
         //std::cout << "collidables.size(): " << collidables.size() << std::endl; // DEBU
         for (auto &collidable : collidables)
         {
            //bool player_is_already_colliding_on_this_object = false; // TODO: Extract item from list of items

            AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D* this_collidable_as =
               get_entity_as_dynamic_model_3d(collidable);

            float collision_radius = 0.7;
            if (this_collidable_as->exists(ATTRIBUTE_CUSTOM_COLLISION_RADIUS))
            {
               collision_radius = this_collidable_as->get_as_float(ATTRIBUTE_CUSTOM_COLLISION_RADIUS);
            }

            bool player_is_currently_colliding_with_this_object = trivial_collide(
               player_entity_as->get_placement_ref().position,
               this_collidable_as->get_placement_ref().position,
               collision_radius
            );

            bool player_is_previously_colliding_with_this_object =
               entities_player_entity_is_colliding_with.find(collidable)
                  != entities_player_entity_is_colliding_with.end();

            if (player_is_currently_colliding_with_this_object)
            {
               if (!player_is_previously_colliding_with_this_object)
               {
                  // On enter
                  entities_player_entity_is_colliding_with.insert(collidable);
                  // TODO: Maybe have an entered_collision_at for certain collision objects?
                  on_player_entity_enter_collide(this_collidable_as);
               }
               else
               {
                  // Continuing to collide. So, already colliding, do nothing.
               }
            }
            else
            {
               if (player_is_previously_colliding_with_this_object)
               {
                  // On exit
                  // TODO: Consider checking presence before erasing
                  entities_player_entity_is_colliding_with.erase(collidable);
                  // TODO: Maybe have a exited_collision_at for certain collision objects?
                  on_player_entity_exit_collide(this_collidable_as);
               }
               else
               {
                  // Do nothing, no collision now or after.
               }
            }
         }
      }



      //if (is_state(SUSPEND_FOR_DIALOG))
      //{
         
      //}

      // Check player collision on item
      //if (player_controlled_entity && goal_entity)
      //{
         //auto player_entity_as = get_player_controlled_entity_as();
      //}
      


      // Rotate objects in the scene
      //item->get_placement_ref().rotation.x += 0.005;
      //item->get_placement_ref().rotation.z += 0.003547;
      return;
    body_dependency_symbols:
      - std::cos
      - std::sin
      - std::fabs
      - std::fmod
      - LabyrinthOfLore::Physics::EntityTileMapCollisionStepper
      - Pipeline::Physics::GravityStepper
      - Pipeline::CurrentFloorInferencer
      - AllegroFlare::Physics::AABB3D


  - name: toggle_showing_map_overlay
    body: |
      show_map_overlay = !show_map_overlay;
      return;


  - name: render
    guards: [ initialized, current_level ]
    body: |
      ALLEGRO_BITMAP *initial_target_bitmap = al_get_target_bitmap();

      // Render the scene
      scene_renderer.render();
      ALLEGRO_BITMAP *render_surface = scene_renderer.get_render_surface_ref().obtain_surface();

      al_set_target_bitmap(initial_target_bitmap);
      al_draw_bitmap(render_surface, 0, 0, 0);

      // Slopily render the tile map

      //al_clear_depth_buffer(1.0);

         auto player_entity_as = get_player_controlled_entity_as();
         float player_elevation = player_entity_as->get_placement_ref().position.y;
         std::map<int, float> floor_elevations = build_elevations_and_indices_for_floors();
         Pipeline::CurrentFloorInferencer floor_inferencer(floor_elevations);
         //floor_inferencer.set_elevationMap(floor_elevations);
         int closest_floor_index = floor_inferencer.find_closest_floor(player_elevation);

      //bool show_map_overlay = false;
      if (show_map_overlay)
      {
         ////////////////////////////////////////////////////// TODO: Pass along floor that you want to see on map ////////////////////
         LabyrinthOfLore::WorldMap::TileMap *current_level_tile_map = get_current_level_tile_map(closest_floor_index); // TODO: Pass argument

         int tile_size = 32;
         AllegroFlare::Vec2D current_level_tile_map_origin_offset = current_level->get_tile_maps()[closest_floor_index].get_origin_offset();
         float groundlevel_height = current_level->get_tile_maps()[closest_floor_index].get_groundlevel_height();
         //AllegroFlare::Vec2D current_level_tile_map_origin_offset = current_level_tile_map->get_origin_offset();
         AllegroFlare::Vec3D player_position = get_player_controlled_entity_as()->get_placement_ref().position;
         AllegroFlare::Vec2D tile_alignment_offset = current_level_tile_map_tile_alignment_offset;
         float player_map_position_x =
            (player_position.x + current_level_tile_map_origin_offset.x + tile_alignment_offset.x) * tile_size;
         float player_map_position_y =
            (player_position.z + current_level_tile_map_origin_offset.y + tile_alignment_offset.y) * tile_size;

         AllegroFlare::Placement3D map_placement;
         map_placement.position.x = 1920/2 - player_map_position_x;
         map_placement.position.y = 1080/2 - player_map_position_y;

         //map_placement.rotation.x = 0.35;
         map_placement.start_transform();
         LabyrinthOfLore::WorldMap::BasicRenderer basic_renderer;
         basic_renderer.set_tile_map(current_level_tile_map);
         basic_renderer.set_tile_width(tile_size);
         basic_renderer.set_tile_height(tile_size);
         basic_renderer.set_groundlevel_height(groundlevel_height);
         basic_renderer.render();

         // Draw the player marker
         al_draw_filled_circle(
            player_map_position_x, //player_position.x * basic_renderer.get_tile_width(),
            player_map_position_y, //player_position.z * basic_renderer.get_tile_height(),
            8,
            al_color_name("azure")
         );
         map_placement.restore_transform();

         ALLEGRO_FONT *ui_font = obtain_ui_font();
         ALLEGRO_COLOR hud_text_color = al_color_name("cyan");
         std::stringstream coordinates;
         coordinates << std::setprecision(3) << player_position.x << ", " << player_position.z;
         al_draw_text(ui_font, hud_text_color, 1920 - 300, 1080 - 200, ALLEGRO_ALIGN_RIGHT, coordinates.str().c_str());
         std::stringstream coordinates2;
         coordinates2 << std::setprecision(3) << player_position.y;
         al_draw_text(ui_font, hud_text_color, 1920 - 300, 1080 - 200 + 20, ALLEGRO_ALIGN_RIGHT, coordinates2.str().c_str());
      }


      // draw light coordinates
      {
         AllegroFlare::Camera3D *light = scene_renderer.get_shadow_map_buffer_ref().get_light();
         ALLEGRO_FONT *ui_font = obtain_ui_font();
         ALLEGRO_COLOR hud_text_color = al_color_name("cyan");
         std::stringstream coordinates;
         coordinates << "tilt (TOD): " << std::setprecision(3) << (light->tilt / 3.14159);
         al_draw_text(ui_font, hud_text_color, 1920 - 300, 1080 - 100, ALLEGRO_ALIGN_RIGHT, coordinates.str().c_str());
         std::stringstream coordinates2;
         coordinates2 << "spin: " << std::setprecision(3) << light->spin;
         al_draw_text(ui_font, hud_text_color, 1920 - 300, 1080 - 100 + 20, ALLEGRO_ALIGN_RIGHT, coordinates2.str().c_str());
      }


      //AllegroFlare::Camera3D *light = scene_renderer.get_shadow_map_buffer_ref().get_light();
         //al_draw_text(ui_font, hud_text_color, 1920 - 300, 1080 - 200 + 20, ALLEGRO_ALIGN_RIGHT, coordinates2.str().c_str());

      return;
    body_dependency_symbols:
      - LabyrinthOfLore::WorldMap::BasicRenderer
      - al_color_name
      - std::setprecision
      


  - name: save_bitmap_buffers_to_files
    body: |
      ALLEGRO_BITMAP *render_surface = scene_renderer.get_render_surface_ref().obtain_surface();

      std::string location_for_saving_files = "tmp/";
      bool directory_creation_successful = al_make_directory(location_for_saving_files.c_str());
      if (!directory_creation_successful)
      {
         // TODO: Consider if should throw, create notification, something else.
      }

      // Save the shadow depth map render
      bool file1_ok = al_save_bitmap(
         (location_for_saving_files + "shadow_depth_map_bitmap.png").c_str(),
         scene_renderer.get_shadow_map_buffer_ref().get_shadow_depth_map_renderer_ref().get_result_surface_bitmap()
      );

      // Save the shadow_buffer
      bool file2_ok = al_save_bitmap(
         (location_for_saving_files + "shadow_buffer_bitmap.png").c_str(),
         scene_renderer.get_shadow_map_buffer_ref().get_result_bitmap()
      );

      // Save the scene
      bool file3_ok = al_save_bitmap(
         (location_for_saving_files + "render_surface.png").c_str(),
         scene_renderer.get_render_surface_ref().obtain_surface()
      );
      return;


  - name: call_on_finished_callback_func
    body: |
      // TODO: Test this callback call
      if (on_finished_callback_func) on_finished_callback_func(this, on_finished_callback_func_user_data);


  - name: on_event
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ ev ]
    body: |
      if (ev->type == ALLEGRO_FLARE_EVENT_DIALOG_SWITCHED_OUT && is_state(STATE_SUSPEND_FOR_DIALOG))
      {
         set_state(STATE_PLAYING_GAME);
      }
      return;
    body_dependency_symbols:
      - ALLEGRO_FLARE_EVENT_DIALOG_SWITCHED_OUT


  - name: game_event_func
    virtual: true
    override: true
    parameters:
      - name: game_event
        type: AllegroFlare::GameEvent*
        default_argument: nullptr
    guards: [ game_event ]
    body: |
      if (game_event->is_type("perform_music"))
      {
         if (!current_level)
         {
            AllegroFlare::Logger::throw_error(
               "Pipeline::Gameplay::Screen::game_event_func",
               "On game event \"perform_music\", current_level cannot be nullptr."
            );
         }

         std::string song_to_perform_identifier = current_level->get_song_to_perform_identifier();
         float song_to_perform_duration_sec = current_level->get_song_to_perform_duration_sec();
         activate_music_performance(song_to_perform_identifier, song_to_perform_duration_sec);
      }
      //else if (game_event->is_type("collect_special_item"))
      //{
         //activate_music_performance(current_level_song_to_perform_identifier);
      //}
      return;


  - name: primary_timer_func
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      update();
      render();
      return;


  - name: display_switch_in_func
    virtual: true
    override: true
    guards: [ initialized, event_emitter ]
    body: |
      load_tile_map(current_level_identifier); // DEVELOPMENT
      return;
   

  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event_emitter ]
    body: |
      if (!is_state(STATE_PLAYING_GAME)) return;

      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_UP:
         case ALLEGRO_KEY_DOWN: {
            player_control_velocity.y = 0;
         } break;

         case ALLEGRO_KEY_LEFT:
         case ALLEGRO_KEY_RIGHT: {
            player_control_velocity.x = 0;
         } break;

         case ALLEGRO_KEY_R: {
            player_control_dashing = false;
         } break;

         default: {
            //attempt_an_action_at(ev->keyboard.keycode);
         } break;
      }

      return;
    body_dependency_symbols: []


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event_emitter ]
    body: |
      // Debugging
      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_0: {
            save_bitmap_buffers_to_files();
         } break;

         case ALLEGRO_KEY_L: {
            load_tile_map(current_level_identifier);
         } break;

         case ALLEGRO_KEY_M: {
            toggle_showing_map_overlay();
         } break;

         default: {
         } break;
      }

      // Cancel out of music performance
      if (is_state(STATE_PERFORMING_MUSIC))
      {
         switch(ev->keyboard.keycode)
         {
            case ALLEGRO_KEY_X: {
               deactivate_music_performance();
            } break;

            default: {
            } break;
         }
      }

      if (!is_state(STATE_PLAYING_GAME)) return;

      // Normal gameplay controls
      switch(ev->keyboard.keycode)
      {
         case ALLEGRO_KEY_UP: {
            player_control_velocity.y = -1.0;
            //move_development_cursor_up();
         } break;

         case ALLEGRO_KEY_DOWN: {
            player_control_velocity.y = 1.0;
            //move_development_cursor_down();
         } break;

         case ALLEGRO_KEY_LEFT: {
            player_control_velocity.x = -1.0;
            //move_development_cursor_down();
         } break;

         case ALLEGRO_KEY_RIGHT: {
            player_control_velocity.x = 1.0;
            //move_development_cursor_down();
         } break;

         case ALLEGRO_KEY_R: {
            player_control_dashing = true;
         } break;

         //case ALLEGRO_KEY_P: {
            //activate_music_performance(current_level_song_to_perform_identifier);
            ////move_development_cursor_down();
         //} break;

         //case ALLEGRO_KEY_X: {
            //deactivate_music_performance();
            ////move_development_cursor_down();
         //} break;

         // TODO: Deliver the package with "enter"
         //case ALLEGRO_KEY_ENTER: {
            //attempt_to_deliver_package();
         //} break;

         default: {
            //attempt_an_action_at(ev->keyboard.keycode);
         } break;
      }

      return;
    body_dependency_symbols: []


  - name: joy_button_down_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, ev, event_emitter ]
    body: |
      int button = ev->joystick.button;

      std::cout << "joy button event (" << ev->joystick.id << ")" << std::endl;
      std::cout << "   button: " << ev->joystick.button << std::endl;

      // Cancel out of music performance
      if (is_state(STATE_PERFORMING_MUSIC))
      {
         // Use just any button to skip performance
         deactivate_music_performance();
         return;
      }


      if (!is_state(STATE_PLAYING_GAME)) return;

      player_control_dashing = true; // Any button activates run

      return;
    body_dependency_symbols: []


  - name: joy_button_up_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, ev, event_emitter ]
    body: |
      int button = ev->joystick.button;

      std::cout << "joy button UP event (" << ev->joystick.id << ")" << std::endl;
      std::cout << "   button: " << ev->joystick.button << std::endl;

      if (!is_state(STATE_PLAYING_GAME)) return;

      player_control_dashing = false; // Any button activates run

      return;
    body_dependency_symbols: []


  - name: joy_axis_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, ev, event_emitter ]
    body: |
      if (!is_state(STATE_PLAYING_GAME)) return;

      //std::cout << "joy event (" << ev->joystick.id << ")" << std::endl;
      //std::cout << "   stick: " << ev->joystick.stick << std::endl;
      //std::cout << "   axis: " << ev->joystick.axis << std::endl;
      //std::cout << "   pos: " << ev->joystick.pos << std::endl;
      float min_stick_threshold = 0.2;

      int stick = ev->joystick.stick;
      int axis = ev->joystick.axis;
      float pos = ev->joystick.pos;
      switch (stick)
      {
         case 0: { // The primary joystick, on the left
           if (axis == 0) // horizontal axis
           {
              if (std::fabs(pos) < min_stick_threshold) player_control_velocity.x = 0;
              else player_control_velocity.x = pos;
           }
           else if (axis == 1) // vertical axis
           {
              if (std::fabs(pos) < min_stick_threshold) player_control_velocity.y = 0;
              else player_control_velocity.y = pos;
           }
         } break;

         case 1: { // The secondary joystick, on the right
         } break;

         case 2: { // The hat, on the left
         } break;
      }
 
      return;
    body_dependency_symbols:
      - std::fabs


  - name: virtual_control_button_up_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      // TODO: this function
      return;


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      // TODO: this function
      //call_on_finished_callback_func(); // Consider technique to exit
      return;


  - name: virtual_control_axis_change_func
    virtual: true
    override: true
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized ]
    body: |
      // TODO: this function
      return;


  - name: activate_music_performance
    parameters:
      - name: music_identifier
        type: std::string
        default_argument: '"[unset-music_identifier]"'
      - name: duration_sec
        type: float
        default_argument: 10.0f
    xguards: [ (!is_state(STATE_PERFORMING_MUSIC)) ]
    body: |
      if (is_state(STATE_PERFORMING_MUSIC)) return; // TODO: Test this
      // Set our current song state variables
      // TODO: Validate music track exists
      currently_performing_song_identifier = music_identifier;
      currently_performing_song_duration_sec = duration_sec; // TODO: Replace this hard-coded value with the actual duration
      //currently_performing_song_duration_sec = 5.0; // TODO: Replace this hard-coded value with the actual duration
                                                    // of the currently_performing_song_identifier

      // Set the player to a good front-facing rotation for performance 
      auto player_entity_as = get_player_controlled_entity_as();
      player_entity_as->get_placement_ref().rotation = { 0.0, -0.25, 0.0 };

      // Set the control text @ bottom of screen to show skippable cutscene controls
      std::vector<std::string> tokens = {
         //"I", "%SPACER", "LABEL>>", "Toggle inventory", 
         //"%SEPARATOR",
         //"X", "%SPACER", "LABEL>>", "Exit", 
         //"%SEPARATOR",
         "X", "%SPACER", "LABEL>>", "Skip", 
         //"%SEPARATOR",
         //"P", "%SPACER", "LABEL>>", "Pause", 
         //"%SEPARATOR",
         //"SHIFT", "%SPACE", "%PLUS", "%SPACE", "ESC", "%SPACER", "LABEL>>", "Exit program", 
      };
      event_emitter->emit_set_input_hints_bar_event(tokens);
      event_emitter->emit_show_input_hints_bar_event();
      event_emitter->emit_set_input_hints_bar_text_opacity_event(1.0);
      
      // Play the music track
      event_emitter->emit_play_music_track_event(currently_performing_song_identifier);

      // Set the state
      set_state(STATE_PERFORMING_MUSIC);
      return;


  - name: deactivate_music_performance
    guards: [ current_level ]
    body: |
      if (!is_state(STATE_PERFORMING_MUSIC)) return; // TODO: Test this

      event_emitter->emit_stop_all_music_tracks_event(); // TODO: Consider if alternative would be better than stopping
                                                         // everything.
      currently_performing_song_identifier = "";
      currently_performing_song_duration_sec = 0.0;

      // Hide the input hings bar
      event_emitter->emit_hide_input_hints_bar_event();

      // Emit an event that the package was delivered
      event_emitter->emit_game_event(
         AllegroFlare::GameEvent(
            "package_delivered",
            new AllegroFlare::GameEventDatas::String(current_level_identifier) //"world-1-05")
         )
      );

      std::string level_music_identifier = current_level->get_background_music_identifier();
      event_emitter->emit_play_music_track_event(level_music_identifier);
      set_state(STATE_PLAYING_GAME);
      // TODO: Consider how to re-activate current level music
      return;
    body_dependency_symbols:
      - AllegroFlare::GameEventDatas::String


  - name: emit_event_to_save_progress
    guards: [ event_emitter ]
    body: |
      // TODO: Test this
      // TODO: Consider using a constant rather than "save_progress"
      event_emitter->emit_game_event(AllegroFlare::GameEvent("save_progress"));
      return;


  - name: set_state
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
      - name: override_if_busy
        type: bool
        default_argument: false
    guards: [ is_valid_state(state) ]
    body: |
      if (this->state == state) return;
      if (!override_if_busy && state_is_busy) return;
      uint32_t previous_state = this->state;

      switch (state)
      {
         case STATE_REVEALING: {
            player_control_velocity = {0, 0};
            player_control_dashing = false;
         } break;

         case STATE_PLAYING_GAME: {
            set_primary_camera_to_gameplay_view(scene_renderer.find_primary_camera_3d());
         } break;

         case STATE_SUSPEND_FOR_DIALOG: {
            set_primary_camera_to_dialog_view(scene_renderer.find_primary_camera_3d());
            player_control_velocity = {0, 0};
            player_control_dashing = false;
         } break;

         case STATE_PERFORMING_MUSIC: {
            set_primary_camera_to_music_performance_view(scene_renderer.find_primary_camera_3d());
         } break;

         default:
            throw std::runtime_error("weird error");
         break;
      }

      this->state = state;
      state_changed_at = al_get_time();

      return;


  - name: normalize_age_no_clamp
    static: true
    type: float
    parameters:
      - name: start_time
        type: float
        default_argument: 0.0f
      - name: end_time
        type: float
        default_argument: 0.0f
      - name: time_now
        type: float
        default_argument: 0.0f
    body: |
      // TODO: Consider that capping to 1.0 if past may not be preferred
      float length = (end_time - start_time);
      float time_now_in_range = time_now - start_time;
      if (length == 0.0f) return 0.0f;
      //if (time_now_in_range >= length) return 1.0f;
      return time_now_in_range / length;


  - name: update_state
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    guards: [ is_valid_state(state) ]
    body: |
      float age = infer_current_state_age(time_now);

      switch (state)
      {
         case STATE_REVEALING: {
         } break;

         case STATE_PLAYING_GAME: {
         } break;

         case STATE_SUSPEND_FOR_DIALOG: {
         } break;

         case STATE_PERFORMING_MUSIC: {
            // TODO: Have camera zoom in slowly
            // If age > song duration, exit
            if (age >= currently_performing_song_duration_sec) deactivate_music_performance();

            // Slowly dolly shot with the camera
            // TODO: Consider doing this with a step-out?
            AllegroFlare::Camera3D *primary_camera = scene_renderer.find_primary_camera_3d();
            float DOLLY_SHOT_DURATION = 12.0;
            float normalized_age = normalize_age_no_clamp(
                  state_changed_at,
                  state_changed_at + DOLLY_SHOT_DURATION,
                  time_now
               );
            if (normalized_age >= 0.0f && normalized_age <= 1.0f)
            {
               float speed_multiplier = 1.0; // - AllegroFlare::interpolator::fast_in(normalized_age);
               if (normalized_age >= 0.5)
               {
                  float local = (normalized_age - 0.5) * 2;
                  speed_multiplier = 1.0 - AllegroFlare::interpolator::slow_out(local);
               }
               float zoom_speed = 0.001f * speed_multiplier;
               //float zoom_speed = 0.0012f * speed_multiplier;
               primary_camera->zoom += zoom_speed;
            }

            // Rotate character along a sine wave (dancing)
            auto player_entity_as = get_player_controlled_entity_as();
            player_entity_as->get_placement_ref().rotation.z = std::sin(age * 3) * 0.012;
         } break;

         default: {
            throw std::runtime_error("weird error");
         } break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::Interpolators


  - name: is_valid_state
    type: bool
    static: true
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
      std::set<uint32_t> valid_states =
      {
         STATE_REVEALING,
         STATE_PLAYING_GAME,
         STATE_SUSPEND_FOR_DIALOG,
         STATE_PERFORMING_MUSIC,
      };
      return (valid_states.count(state) > 0);
    body_dependency_symbols:
      - std::set


  - name: is_state
    type: bool
    parameters:
      - name: possible_state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
     return (state == possible_state);


  - name: infer_current_state_age
    type: float
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    body: |
      return (time_now - state_changed_at);


  - name: obtain_ui_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      return font_bin->auto_get("Oswald-Medium.ttf -32");


dependencies:


  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::ModelBin
    headers: [ AllegroFlare/ModelBin.hpp ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::Player
    headers: [ AllegroFlare/Player.hpp ]
  - symbol: AllegroFlare::VirtualControllers::Base
    headers: [ AllegroFlare/VirtualControllers/Base.hpp ]
  - symbol: Pipeline::Gameplay::Screen
    headers: [ Pipeline/Gameplay/Screen.hpp ]
  - symbol: AllegroFlare::GameConfigurations::Base
    headers: [ AllegroFlare/GameConfigurations/Base.hpp ]
  - symbol: Pipeline::GameConfigurations::Main
    headers: [ Pipeline/GameConfigurations/Main.hpp ]
  - symbol: Pipeline::Gameplay::Level
    headers: [ Pipeline/Gameplay/Level.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityPool.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::SceneRenderer2
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/SceneRenderer2.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityFactory
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityFactory.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/DynamicModel3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityRenderFlags
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityRenderFlags.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/Base.hpp ]
  - symbol: AllegroFlare::Model3D
    headers: [ AllegroFlare/Model3D.hpp ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: AllegroFlare::Vec3D
    headers: [ AllegroFlare/Vec3D.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: ALLEGRO_FLARE_EVENT_DIALOG_SWITCHED_OUT
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::ALLEGRO_VERTEX_WITH_NORMAL
    headers: [ AllegroFlare/ALLEGRO_VERTEX_WITH_NORMAL.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]
  - symbol: AllegroFlare::Frameworks::Full
    headers: [ AllegroFlare/Frameworks/Full.hpp ]
  - symbol: Pipeline::DialogNodeBankFactory
    headers: [ Pipeline/DialogNodeBankFactory.hpp ]
  - symbol: AllegroFlare::MotionKit
    headers: [ AllegroFlare/MotionKit.hpp ]
  - symbol: AllegroFlare::Interpolators
    headers: [ AllegroFlare/Interpolators.hpp ]
  - symbol: Pipeline::GameProgressAndStateInfo
    headers: [ Pipeline/GameProgressAndStateInfo.hpp ]
  - symbol: AllegroFlare::GameEventDatas::String
    headers: [ AllegroFlare/GameEventDatas/String.hpp ]
  - symbol: std::cos
    headers: [ cmath ]
  - symbol: std::sin
    headers: [ cmath ]
  - symbol: std::fabs
    headers: [ cmath ]
  - symbol: std::fmod
    headers: [ cmath ]
  - symbol: LabyrinthOfLore::WorldMap::TileMap
    headers: [ LabyrinthOfLore/WorldMap/TileMap.hpp ]
  - symbol: LabyrinthOfLore::WorldMap::TileTypeEnum
    headers: [ LabyrinthOfLore/WorldMap/TileTypeEnum.hpp ]
  - symbol: LabyrinthOfLore::WorldMap::BasicRenderer
    headers: [ LabyrinthOfLore/WorldMap/BasicRenderer.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: std::setprecision
    headers: [ iomanip ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: LabyrinthOfLore::Physics::EntityTileMapCollisionStepper
    headers: [ LabyrinthOfLore/Physics/EntityTileMapCollisionStepper.hpp ]
  - symbol: LabyrinthOfLore::WorldMap::MultiBitmapFilenameToWorldBuilder
    headers: [ LabyrinthOfLore/WorldMap/MultiBitmapFilenameToWorldBuilder.hpp ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: Pipeline::Physics::GravityStepper
    headers: [ Pipeline/Physics/GravityStepper.hpp ]
  - symbol: Pipeline::CSVToLevelLoader
    headers: [ Pipeline/CSVToLevelLoader.hpp ]
  - symbol: Pipeline::CurrentFloorInferencer
    headers: [ Pipeline/CurrentFloorInferencer.hpp ]
  - symbol: Pipeline::OBJWorldLoader
    headers: [ Pipeline/OBJWorldLoader.hpp ]
  - symbol: Pipeline::EntityAttributes
    headers: [ Pipeline/EntityAttributes.hpp ]
  - symbol: AllegroFlare::Physics::AABB3D
    headers: [ AllegroFlare/Physics/AABB3D.hpp ]
  - symbol: Pipeline::Gameplay::LevelCameraZone
    headers: [ Pipeline/Gameplay/LevelCameraZone.hpp ]
  - symbol: AllegroFlare::Camera3D
    headers: [ AllegroFlare/Camera3D.hpp ]


